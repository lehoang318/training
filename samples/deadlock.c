#include "common.h"

#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

//////////////////////////////////////////////////////////////////////////////////////////////////
//  DATA TYPES
/////////////////////////////

// Define the structure to be shared
typedef struct shared_resource {
    pthread_mutex_t mutex_x;
    int x;

    pthread_mutex_t mutex_y;
    int y;
} shared_resource_t;

// A unique name for the shared memory object
#define SHM_NAME "/posix_shm_sync_example"

//////////////////////////////////////////////////////////////////////////////////////////////////
//  GLOBAL DATA
/////////////////////////////

// [Parent] Termination flag
static volatile sig_atomic_t flag_term = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////
//  PROTOTYPES
/////////////////////////////

// [Parent] Handler for `SIGUSR1` signal
static void handler_SIGUSR1(int signum);

// Function to handle errors and exit
static void error_exit(const char * const msg);

// Function to calculate a timeout for pthread_mutex_timedlock
struct timespec get_timespec(const long seconds);

// Function to initialize the shared memory structure
static shared_resource_t * init_shared_resource(const size_t shm_size);

// Function to clean up the shared memory (called by the creator/parent)
static void cleanup_shared_resource(shared_resource_t * const shm_ptr, const size_t shm_size);

// Main processes' tasks
static void parent_task(const int child_pid, shared_resource_t * const shm_ptr, const size_t shm_size);
static void child_task(shared_resource_t * const shm_ptr, const size_t shm_size);

//////////////////////////////////////////////////////////////////////////////////////////////////
//  IMPLEMENTATION
/////////////////////////////

int main() {
    printf("\n**Disclaimer: This application was generated by GenAI.**\n\n");

    const size_t shm_size = sizeof(shared_resource_t);
    shared_resource_t * shm_ptr = init_shared_resource(shm_size);

    if (0 != signal(SIGUSR1, &handler_SIGUSR1)) {
        error_exit("Failed to register SIGUSR1's handler!");
    }

    int pid = fork();
    switch (pid) {
        case 0:
            child_task(shm_ptr, shm_size);
            break;

        case -1:
            cleanup_shared_resource(shm_ptr, shm_size);
            error_exit("Failed to fork a child process!");
            break;

        default:
            logi("Child process (%04d) has been forked, continuing main task ...", pid);
            parent_task(pid, shm_ptr, shm_size);
            break;
    }

    return EXIT_SUCCESS;
}

// Function to handle errors and exit
static void error_exit(const char * const msg) {
    loge("%s (%s)!", msg, strerror(errno));
    // Attempt to unlink the shared memory in case it was created
    shm_unlink(SHM_NAME);
    exit(EXIT_FAILURE);
}

// [Parent] Handler for `SIGUSR1` signal
static void handler_SIGUSR1(int signum) {
    if (SIGUSR1 == signum) {
        flag_term = 1;
    }
}

// Function to calculate a timeout for pthread_mutex_timedlock
struct timespec get_timespec(long seconds) {
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += seconds;
    return ts;
}

// Function to initialize the shared memory structure
static shared_resource_t * init_shared_resource(const size_t shm_size) {
    shared_resource_t * shm_ptr = NULL;
    pthread_mutexattr_t attr;
    int ret;

    int shm_fd;

    // Create the shared memory object (assumption: default umask is `022`)
    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    if (shm_fd == -1) {
        error_exit("Failed to create a shared memory object!");
    }
    if (ftruncate(shm_fd, shm_size) == -1) {
        error_exit("Failed to resize the shared memory object!");
    }

    // Map the shared memory object
    shm_ptr = mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        error_exit("Failed to map the shared memory area to the process memory space!");
    }

    close(shm_fd);

    // Initialize shared data
    shm_ptr->x = 0;
    shm_ptr->y = 0;

    // Initialize mutex attributes
    if ((ret = pthread_mutexattr_init(&attr)) != 0) {
        error_exit("Failed to initialize pthread attribute object!");
    }

    // Set the mutexes to be process-shared
    if ((ret = pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED)) != 0) {
        pthread_mutexattr_destroy(&attr);
        error_exit("Failed to change pthread attribute!");
    }

    // Initialize mutex_x and mutex_y
    if ((ret = pthread_mutex_init(&shm_ptr->mutex_x, &attr)) != 0) {
        pthread_mutexattr_destroy(&attr);
        error_exit("Failed to initialize mutex_x!");
    }

    if ((ret = pthread_mutex_init(&shm_ptr->mutex_y, &attr)) != 0) {
        pthread_mutex_destroy(&shm_ptr->mutex_x); // Clean up
        pthread_mutexattr_destroy(&attr);
        error_exit("Failed to initialize mutex_y!");
    }

    // Destroy the mutex attributes object
    pthread_mutexattr_destroy(&attr);

    logi("Initialized shared resource!");

    return shm_ptr;
}

// Function to clean up the shared memory (called by the creator/parent)
static void cleanup_shared_resource(shared_resource_t * const shm_ptr, const size_t shm_size) {
    logi("Cleaning up shared resources ...");

    // Destroy mutexes
    pthread_mutex_destroy(&shm_ptr->mutex_x);
    pthread_mutex_destroy(&shm_ptr->mutex_y);

    // Unmap the shared memory
    if (munmap(shm_ptr, shm_size) == -1) {
        loge("Failed to unmap the shared memory: %s!", strerror(errno));
    }

    // Unlink the shared memory object
    if (shm_unlink(SHM_NAME) == -1) {
        loge("Failed to unlink the shared memory's file: %s!", strerror(errno));
    }
}

// Parent process logic
static void parent_task(const int child_pid, shared_resource_t * const shm_ptr, const size_t shm_size) {
    int ret;

    // --- lock mutex_x then update x with its Process ID ---
    if ((ret = pthread_mutex_lock(&shm_ptr->mutex_x)) != 0) {
        loge("pthread_mutex_lock (mutex_x) failed: %s!", strerror(ret));
        goto end_parent;
    }
    shm_ptr->x = getpid();
    logi("Locked mutex_x. Updated x = %d.", shm_ptr->x);

    logi("Sleeping for 1s ...");
    sleep(1);

    // The child process has started and locked mutex_y at this point, leading to a deadlock condition.
    // Parent holds mutex_x, wants mutex_y.
    // Child holds mutex_y, wants mutex_x.

    // --- lock mutex_y then print the value of y ---
    if ((ret = pthread_mutex_lock(&shm_ptr->mutex_y)) != 0) {
        loge("pthread_mutex_lock (mutex_y) failed: %s!", strerror(ret));
        pthread_mutex_unlock(&shm_ptr->mutex_x); // Self-release the held lock
        goto end_parent;
    }
    logi("Locked mutex_y => ${y} = %d.", shm_ptr->y);

    // --- unlock mutex_y ---
    pthread_mutex_unlock(&shm_ptr->mutex_y);
    logi("Unlocked mutex_y.");

    // --- unlock mutex_x ---
    pthread_mutex_unlock(&shm_ptr->mutex_x);
    logi("Unlocked mutex_x.");

    
end_parent:;
    // --- wait for the termination signal ---
    logi("Waiting for termination signal (`kill -s SIGUSR1 %d`) ...", getpid());
    for (int i = 0; (10 > i) && (0 == flag_term); i++) {
        sleep(1);
    }

    if (0 == flag_term) {
        logw("Timeout while waiting for termination signal!");
    }

    // --- wait for the termination of the child process ---
    int status;
    if (waitpid(child_pid, &status, 0) == -1) {
        perror("waitpid");
    } else {
        logi("Child process (%04d) finished.", child_pid);
    }

    // --- Cleanup ---
    cleanup_shared_resource(shm_ptr, shm_size);

    logi("Terminating ...");
}

// Child process logic
static void child_task(shared_resource_t * const shm_ptr, const size_t shm_size) {
    int ret;
    struct timespec ts;

    logi("Starting ...");

    // --- lock mutex_y then update y with its Process ID ---
    if ((ret = pthread_mutex_lock(&shm_ptr->mutex_y)) != 0) {
        loge("pthread_mutex_lock (mutex_y) failed: %s!", strerror(ret));
        exit(EXIT_FAILURE);
    }
    shm_ptr->y = getpid();
    logi("Locked mutex_y. Updated y = %d.", shm_ptr->y);

    // --- sleep for 1s ---
    sleep(1);

    // --- lock mutex_x with timeout 1s ---
    ts = get_timespec(30); // 30-second timeout
    logi("Attempting to lock mutex_x with 30s timeout ...");

    ret = pthread_mutex_timedlock(&shm_ptr->mutex_x, &ts);

    if (ret == 0) {
        // --- if lock returns success, print the value of x ---
        logi("Successfully locked mutex_x. Value of x = %d.", shm_ptr->x);

        // Unlock both
        pthread_mutex_unlock(&shm_ptr->mutex_x);
        pthread_mutex_unlock(&shm_ptr->mutex_y);
    } else if (ret == ETIMEDOUT) {
        // --- else print "Timeout, Deadlock!" ---
        logi("Timeout(as expected), recovering from `Deadlock` ...");

        // --- release mutex_y ---
        pthread_mutex_unlock(&shm_ptr->mutex_y);
        logi("Released mutex_y.");

        // This will now succeed because the parent is blocking on mutex_y (which is now free)
        // and the parent's successful acquisition of mutex_y will lead to it releasing mutex_x.
        // The child will now wait for the parent to release mutex_x.

        // --- lock mutex_x then print the value of x ---
        logi("Re-attempting to lock mutex_x ...");
        if ((ret = pthread_mutex_lock(&shm_ptr->mutex_x)) != 0) {
             loge("pthread_mutex_lock (mutex_x) failed: %s!", strerror(ret));
             exit(EXIT_FAILURE);
        }
        logi("Locked mutex_x => ${x} = %d.", shm_ptr->x);
        pthread_mutex_unlock(&shm_ptr->mutex_x);
        logi("Unlocked mutex_x.");

    } else {
        // Other errors
        loge("pthread_mutex_timedlock (mutex_x) failed: %s!", strerror(ret));
        pthread_mutex_unlock(&shm_ptr->mutex_y);
        exit(EXIT_FAILURE);
    }

    logi("Terminating ...");

    // Unmap the shared memory
    if (munmap(shm_ptr, shm_size) == -1) {
        loge("Failed to unmap the shared memory: %s!", strerror(errno));
    }
}
